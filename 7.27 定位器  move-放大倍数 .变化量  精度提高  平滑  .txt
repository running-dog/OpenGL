//7.27   定位器按照规划点    move=放大倍数*Δx  精度提高 平滑移动   
//放大倍数*Δx   走位量是精确放大的  精度满足


#include <glad/glad.h>        
#include <GLFW/glfw3.h>

#include <gl/glut.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>

#include <learnopengl/filesystem.h>
#include <learnopengl/shader_m.h>
#include <learnopengl/camera.h>
#include <learnopengl/model.h>

#include <iostream>

void framebuffer_size_callback(GLFWwindow* window, int width, int height);
void mouse_callback(GLFWwindow* window, double xpos, double ypos);
void scroll_callback(GLFWwindow* window, double xoffset, double yoffset);
void processInput(GLFWwindow *window);
void judge_move();
void key_callback(GLFWwindow* window, int key, int scancode, int action, int mode);
void jude_viewlock();

//void do_movement();
//void jude_direction();
void  jude_direction_change();
void do_movement_slider_1();
void do_movement_slider_2();
void do_movement_slider_3();
void do_movement_slider_4();

//------------------------------------       camera自定义
//void mouse_callback(GLFWwindow* window, double xpos, double ypos);
float yaw = -90.0f;
float pitch = 0.0f;

glm::vec3 cameraPos = glm::vec3(30.0f, 30.0f, 30.0f);  //摄像机位置
glm::vec3 cameraFront = glm::vec3(15.0f, 0.0f, 15.0f) - glm::vec3(30.0f, 30.0f, 30.0f);//摄像机视线方向
glm::vec3 cameraUp = glm::vec3(0.0f, 1.0f, 0.0f);
float viewlocker = 0.0f;

glm::vec3 cameraFront_now = cameraFront;

//glm::mat4 view = view = glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp);
//------------------------------------



// settings    设置窗口宽高
const unsigned int SCR_WIDTH = 1000;
const unsigned int SCR_HEIGHT = 800;

// camera         
Camera camera(glm::vec3(0.0, 0.0, 20.0));
float lastX = SCR_WIDTH / 2.0;
float lastY = SCR_HEIGHT / 2.0;
float fov = 45.0;
//float lastX = SCR_WIDTH;
//float lastY = SCR_HEIGHT;
bool firstMouse = true;

// timing
float deltaTime = 0.0;
float lastFrame = 0.0;

bool keys[1024];
float  angle = 0.0;
GLfloat movespeed = 0.3;   //设置的移动速度
GLfloat velocity;
float scale_proportion = 0.1; //模型大小设置的缩放比例
float smooth_steps = 1 / 600.0;  //平滑的步数
float arrive_interval = 0.01;
double magnify_slidermove = 0.25e8;  //定位器移动量的放大倍数

struct Point {
	double  x;
	double y;
	double z;
};

Point trans_point[] = {

	{ 11702.15617438560, 581.03223938796,  3261.15608958024},
	{ 11643.29659054430, 1014.21458105330, 1978.42996869193},
	{ 13168.57988926790, 1014.79342543805, 1911.76022939268},
	{ 13216.88453858120, 575.78884948872,  3194.10601819121},

	{ 11702.15617438660 ,581.03223938907, 3261.15608957777 },
	{ 11643.29659054530 ,1014.21458105247,1978.42996868880},
	{ 13168.57988926890 ,1014.79342543038,1911.76022938731},
	{ 13216.88453858210 ,575.78884948302, 3194.10601818653},

	{ 11702.15617439360 ,581.03223939682, 3261.15608956045},
	{ 11643.29659055260 ,1014.21458104671,1978.42996866690 },
	{ 13168.57988927550 ,1014.79342537664,1911.76022934978 },
	{ 13216.88453858820 ,575.78884944312, 3194.10601815375 }
};

double 	arrive_group_copy[4][3];
double 	arrive_group[4][3];

int length;//length 为传过来的点的个数

		   
//1-4号定位器 初始位置向量 --->注意现实坐标系和 仿真空间坐标系之间的 **映射**
glm::vec3 model_pos = glm::vec3(10.0, 0.0, 10.0); //定位器底座
glm::vec3 model_pos_1 = glm::vec3(10.0, 0.0, 10.0);//X_1     
glm::vec3 model_pos_2 = glm::vec3(10.0, 0.0, 10.0);//Y_1   -->正常世界的空间坐标系的三个 方向
glm::vec3 model_pos_3 = glm::vec3(10.0, 0.0, 10.0);//Z_1

glm::vec3 model_pos_4 = glm::vec3(20.0, 0.0, 10.0); //定位器底座
glm::vec3 model_pos_5 = glm::vec3(20.0, 0.0, 10.0);//X_1     
glm::vec3 model_pos_6 = glm::vec3(20.0, 0.0, 10.0);//Y_1   -->正常世界的空间坐标系的三个 方向
glm::vec3 model_pos_7 = glm::vec3(20.0, 0.0, 10.0);//Z_1

glm::vec3 model_pos_8 = glm::vec3(10.0, 0.0, 20.0); //定位器底座
glm::vec3 model_pos_9 = glm::vec3(10.0, 0.0, 20.0);//X_1     
glm::vec3 model_pos_10 = glm::vec3(10.0, 0.0, 20.0);//Y_1   -->正常世界的空间坐标系的三个 方向
glm::vec3 model_pos_11 = glm::vec3(10.0, 0.0, 20.0);//Z_1

glm::vec3 model_pos_12 = glm::vec3(20.0, 0.0, 20.0); //定位器底座
glm::vec3 model_pos_13 = glm::vec3(20.0, 0.0, 20.0);//X_1     
glm::vec3 model_pos_14 = glm::vec3(20.0, 0.0, 20.0);//Y_1   -->正常世界的空间坐标系的三个 方向
glm::vec3 model_pos_15 = glm::vec3(20.0, 0.0, 20.0);//Z_1


//1号定位器各运动轴的运动方向
glm::vec3 slider_1_x_direction = glm::vec3(1.0, 0.0, 0.0);
glm::vec3 slider_1_z_direction = glm::vec3(0.0, 0.0, 1.0);
glm::vec3 slider_1_y_direction = glm::vec3(0.0, 1.0, 0.0);

glm::vec3 slider_2_x_direction = glm::vec3(1.0, 0.0, 0.0);
glm::vec3 slider_2_z_direction = glm::vec3(0.0, 0.0, 1.0);
glm::vec3 slider_2_y_direction = glm::vec3(0.0, 1.0, 0.0);

glm::vec3 slider_3_x_direction = glm::vec3(1.0, 0.0, 0.0);
glm::vec3 slider_3_z_direction = glm::vec3(0.0, 0.0, 1.0);
glm::vec3 slider_3_y_direction = glm::vec3(0.0, 1.0, 0.0);

glm::vec3 slider_4_x_direction = glm::vec3(1.0, 0.0, 0.0);
glm::vec3 slider_4_z_direction = glm::vec3(0.0, 0.0, 1.0);
glm::vec3 slider_4_y_direction = glm::vec3(0.0, 1.0, 0.0);

double slider_1_x_dir_value_change=0;
double slider_1_z_dir_value_change = 0;
double slider_1_y_dir_value_change = 0;

double slider_2_x_dir_value_change = 0;
double slider_2_z_dir_value_change = 0;
double slider_2_y_dir_value_change = 0;

double slider_3_x_dir_value_change = 0;
double slider_3_z_dir_value_change = 0;
double slider_3_y_dir_value_change = 0;

double slider_4_x_dir_value_change = 0;
double slider_4_z_dir_value_change = 0;
double slider_4_y_dir_value_change = 0;



//标准的三方向参考向量
glm::vec3 x_direction = glm::vec3(1.0, 0.0, 0.0);
glm::vec3 z_direction = glm::vec3(0.0, 0.0, 1.0);
glm::vec3 y_direction = glm::vec3(0.0, 1.0, 0.0);

//定位器各方向运动是否到达指定位置 判断标志
bool have_arrive_1_x = false;
bool have_arrive_1_z = false;
bool have_arrive_1_y = false;

bool have_arrive_2_x = false;
bool have_arrive_2_z = false;
bool have_arrive_2_y = false;

bool have_arrive_3_x = false;
bool have_arrive_3_z = false;
bool have_arrive_3_y = false;

bool have_arrive_4_x = false;
bool have_arrive_4_z = false;
bool have_arrive_4_y = false;

bool have_arrive_1 = false;
bool have_arrive_2 = false;
bool have_arrive_3 = false;
bool have_arrive_4 = false;

bool have_one_loop = false;

int raw_slider_1 = 0;
int raw_slider_2 = 1;
int raw_slider_3 = 2;
int raw_slider_4 = 3;

int steps_slider_1 = 0;
int steps_slider_2 = 0;
int steps_slider_3 = 0;
int steps_slider_4 = 0;


int main()
{



	// glfw: initialize and configure
	// ------------------------------
	glfwInit();
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

#ifdef __APPLE__
	glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // uncomment this statement to fix compilation on OS X
#endif

														 // glfw window creation
														 // --------------------
	GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, "LearnOpenGL", NULL, NULL);
	if (window == NULL)
	{
		std::cout << "Failed to create GLFW window" << std::endl;
		glfwTerminate();
		return -1;
	}
	glfwMakeContextCurrent(window);
	glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
	//-------------------------------


	glfwSetCursorPosCallback(window, mouse_callback);


	//----------------------------


	glfwSetScrollCallback(window, scroll_callback);

	// tell GLFW to capture our mouse
	glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);

	//键盘捕捉
	glfwSetKeyCallback(window, key_callback);

	// glad: load all OpenGL function pointers
	// ---------------------------------------
	if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
	{
		std::cout << "Failed to initialize GLAD" << std::endl;
		return -1;
	}

	// configure global opengl state
	// -----------------------------
	glEnable(GL_DEPTH_TEST);

	// build and compile shaders
	// -------------------------
	Shader ourShader("1.model_loading.vs", "1.model_loading.fs");
	// load models
	// -----------
	Model ourModel("D:/5-VScode/test_16/resources/objects/dingweiqi/dizuo.obj");
	Model ourModel_1("D:/5-VScode/test_16/resources/objects/dingweiqi/x_1.obj");
	Model ourModel_2("D:/5-VScode/test_16/resources/objects/dingweiqi/y_1.obj");
	Model ourModel_3("D:/5-VScode/test_16/resources/objects/dingweiqi/z_1.obj");

	Model ourModel_4("D:/5-VScode/test_16/resources/objects/dingweiqi/dizuo.obj");
	Model ourModel_5("D:/5-VScode/test_16/resources/objects/dingweiqi/x_1.obj");
	Model ourModel_6("D:/5-VScode/test_16/resources/objects/dingweiqi/y_1.obj");
	Model ourModel_7("D:/5-VScode/test_16/resources/objects/dingweiqi/z_1.obj");

	Model ourModel_8("D:/5-VScode/test_16/resources/objects/dingweiqi/dizuo.obj");
	Model ourModel_9("D:/5-VScode/test_16/resources/objects/dingweiqi/x_1.obj");
	Model ourModel_10("D:/5-VScode/test_16/resources/objects/dingweiqi/y_1.obj");
	Model ourModel_11("D:/5-VScode/test_16/resources/objects/dingweiqi/z_1.obj");

	Model ourModel_12("D:/5-VScode/test_16/resources/objects/dingweiqi/dizuo.obj");
	Model ourModel_13("D:/5-VScode/test_16/resources/objects/dingweiqi/x_1.obj");
	Model ourModel_14("D:/5-VScode/test_16/resources/objects/dingweiqi/y_1.obj");
	Model ourModel_15("D:/5-VScode/test_16/resources/objects/dingweiqi/z_1.obj");
	//Model ourModel_4(FileSystem::getPath("resources/objects/dingweiqi/dizuo.obj"));

	// draw in wireframe
	//glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);


	//----------------------------------------------------------------
	//第一次走位之前 （进入循环之前）装入目标位置点 
	//arrive_1 = glm::vec3(trans_point[raw_slider_1].x, trans_point[raw_slider_1].y, trans_point[raw_slider_1].z);
	//arrive_2 = glm::vec3(trans_point[raw_slider_2].x, trans_point[raw_slider_2].y, trans_point[raw_slider_2].z);
	//arrive_3 = glm::vec3(trans_point[raw_slider_3].x, trans_point[raw_slider_3].y, trans_point[raw_slider_3].z);
	//arrive_4 = glm::vec3(trans_point[raw_slider_4].x, trans_point[raw_slider_4].y, trans_point[raw_slider_4].z);

	//arrive_1_copy = model_pos_3;  //arrivecopy 装入起始位置点
	//arrive_2_copy = model_pos_7;
	//arrive_3_copy = model_pos_11;
	//arrive_4_copy = model_pos_15;

	length = sizeof(trans_point) / (3 * 4 * 2);//计算传过来的点的个数
	//Point结构体中变量类型  float 3*4   double  3*4*2   //改变结构体变量类型记得回来改这里

	//-----------------------------------------
	//注意现实坐标系和 仿真空间坐标系之间的 **映射**
	arrive_group_copy[0][0] = trans_point[raw_slider_1].x; arrive_group_copy[0][1] = trans_point[raw_slider_1].y; 
	arrive_group_copy[0][2] = trans_point[raw_slider_1].z;
	arrive_group_copy[1][0] = trans_point[raw_slider_2].x; arrive_group_copy[1][1] = trans_point[raw_slider_2].y; 
	arrive_group_copy[1][2] = trans_point[raw_slider_2].z;
	arrive_group_copy[2][0] = trans_point[raw_slider_3].x; arrive_group_copy[2][1] = trans_point[raw_slider_3].y; 
	arrive_group_copy[2][2] = trans_point[raw_slider_3].z;
	arrive_group_copy[3][0] = trans_point[raw_slider_4].x; arrive_group_copy[3][1] = trans_point[raw_slider_4].y; 
	arrive_group_copy[3][2] = trans_point[raw_slider_4].z;

	raw_slider_1 += 4; raw_slider_2 += 4; raw_slider_3 += 4; raw_slider_4 += 4;

	//[][0] [][1]  水平方向  [][2]竖直方向   arrive_group,arrive_group_copy 
	arrive_group[0][0] = trans_point[raw_slider_1].x; arrive_group[0][1] = trans_point[raw_slider_1].y;
	arrive_group[0][2] = trans_point[raw_slider_1].z;  //1号定位器 目标点
	arrive_group[1][0] = trans_point[raw_slider_2].x; arrive_group[1][1] = trans_point[raw_slider_2].y;
	arrive_group[1][2] = trans_point[raw_slider_2].z;  //2号定位器 目标点
	arrive_group[2][0] = trans_point[raw_slider_3].x; arrive_group[2][1] = trans_point[raw_slider_3].y;
	arrive_group[2][2] = trans_point[raw_slider_3].z;  //3号定位器 目标点
	arrive_group[3][0] = trans_point[raw_slider_4].x; arrive_group[3][1] = trans_point[raw_slider_4].y;
	arrive_group[3][2] = trans_point[raw_slider_4].z;  //4号定位器 目标点





	//--------------------------------------------------------------------
	//******计算各个定位器三个轴的移动方向****
	//jude_direction();//计算第一组位置轴的移动方向

	jude_direction_change();

					 // render loop  //循环开始
					 // -----------
	while (!glfwWindowShouldClose(window))
	{
		// per-frame time logic
		// --------------------
		float currentFrame = glfwGetTime();
		deltaTime = currentFrame - lastFrame;
		lastFrame = currentFrame;

		velocity = movespeed * deltaTime;


		// render
		// ------
		glClearColor(0.3f, 0.5f, 1.0f, 1.0f);
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

		// don't forget to enable shader before setting uniforms
		ourShader.use();

		//
		//给定光照
		ourShader.setVec3("viewPos", camera.Position);
		ourShader.setFloat("shininess", 64.0f);
		ourShader.setVec3("light.position", glm::vec3(0.0f, 5.0f, 0.0f));
		ourShader.setVec3("light.ambient", 0.5f, 0.5f, 0.5f);
		ourShader.setVec3("light.diffuse", 0.8f, 0.8f, 0.8f);
		ourShader.setVec3("light.specular", 1.0f, 1.0f, 1.0f);
		ourShader.setFloat("light.constant", 1.0f);
		ourShader.setFloat("light.linear", 0.045f);
		ourShader.setFloat("light.quadratic", 0.0075f);

		GLfloat sun_light_position[] = { 10.0f, 10.0f, 10.0f, 1.0f }; //光源的位置在世界坐标系圆心，齐次坐标形式
		GLfloat sun_light_ambient[] = { 1.0f, 1.0f, 1.0f, 1.0f }; //RGBA模式的环境光，为0
		GLfloat sun_light_diffuse[] = { 1.0f, 1.0f, 1.0f, 1.0f }; //RGBA模式的漫反射光，全白光
		GLfloat sun_light_specular[] = { 1.0f, 1.0f, 1.0f, 1.0f };  //RGBA模式下的镜面光 ，全白光
		glLightfv(GL_LIGHT0, GL_POSITION, sun_light_position);
		glLightfv(GL_LIGHT0, GL_AMBIENT, sun_light_ambient);
		glLightfv(GL_LIGHT0, GL_DIFFUSE, sun_light_diffuse);
		glLightfv(GL_LIGHT0, GL_SPECULAR, sun_light_specular);

		//开启灯光
		glEnable(GL_LIGHT0);
		glEnable(GL_LIGHTING);
		glEnable(GL_DEPTH_TEST);

		//世界空间变换矩阵初始化
		glm::mat4 model = glm::mat4(1.0);
		glm::mat4 model_1 = glm::mat4(1.0);
		glm::mat4 model_2 = glm::mat4(1.0);
		glm::mat4 model_3 = glm::mat4(1.0);

		glm::mat4 model_4 = glm::mat4(1.0);
		glm::mat4 model_5 = glm::mat4(1.0);
		glm::mat4 model_6 = glm::mat4(1.0);
		glm::mat4 model_7 = glm::mat4(1.0);

		glm::mat4 model_8 = glm::mat4(1.0);
		glm::mat4 model_9 = glm::mat4(1.0);
		glm::mat4 model_10 = glm::mat4(1.0);
		glm::mat4 model_11 = glm::mat4(1.0);

		glm::mat4 model_12 = glm::mat4(1.0);
		glm::mat4 model_13 = glm::mat4(1.0);
		glm::mat4 model_14 = glm::mat4(1.0);
		glm::mat4 model_15 = glm::mat4(1.0);

		//视角锁定
		jude_viewlock();





		// view/projection transformations  观察空间   +视角锁定
		//------------------------------------------------------
		//视角锁定 Version2.0
		/*if (viewlocker == 1.0)
		{
		glm::mat4 projection = glm::perspective(glm::radians(camera.Zoom), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f);
		glm::mat4 view = glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp);
		ourShader.setMat4("projection", projection);
		ourShader.setMat4("view", view);//view 观察矩阵
		}
		if (viewlocker==0.0)
		{
		glm::vec3 cameraPos_lock = glm::vec3(30.0f, 30.0f, 30.0f);  //摄像机位置
		glm::vec3 cameraFront_lock = glm::vec3(-1.0f, -1.0f, -1.0f);//摄像机视线方向
		glm::vec3 cameraUp_lock = glm::vec3(0.0f, 1.0f, 0.0f);
		glm::mat4 projection_lock = glm::perspective(glm::radians(camera.Zoom), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f);
		glm::mat4 view_lock = glm::lookAt(cameraPos_lock, cameraPos_lock + cameraFront_lock, cameraUp_lock);
		ourShader.setMat4("projection", projection_lock);
		ourShader.setMat4("view", view_lock);//view 观察矩阵
		}*/

		glm::mat4 projection = glm::perspective(glm::radians(camera.Zoom), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f);
		glm::mat4 view = glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp);
		ourShader.setMat4("projection", projection);
		ourShader.setMat4("view", view);//view 观察矩阵

		// render the loaded model

										//------------------------------------------------
										//小车按键控制随意移动
		judge_move();  //执行前进，计算更新位置向量model_pos_
					   //judge_turn();  //执行旋转，计算更新位置向量model_pos_


		//---------------------------------------------------------------------
		if (have_one_loop)   //have_one_loop==true 则更新下一组 要达到的点
		{
			if (raw_slider_4 < length - 1)//如果不是最后一组位置点-->接着更新位置点组
			{   
				raw_slider_1 += 4;
				raw_slider_2 += 4;
				raw_slider_3 += 4;
				raw_slider_4 += 4;

				arrive_group_copy[0][0] = arrive_group[0][0]; arrive_group_copy[0][1] = arrive_group[0][1]; 
				arrive_group_copy[0][2] = arrive_group[0][2];
				arrive_group_copy[1][0] = arrive_group[1][0]; arrive_group_copy[1][1] = arrive_group[1][1]; 
				arrive_group_copy[1][2] = arrive_group[1][2];
				arrive_group_copy[2][0] = arrive_group[2][0]; arrive_group_copy[2][1] = arrive_group[2][1]; 
				arrive_group_copy[2][2] = arrive_group[2][2];
				arrive_group_copy[3][0] = arrive_group[3][0]; arrive_group_copy[3][1] = arrive_group[3][1];
				arrive_group_copy[3][2] = arrive_group[3][2];

				//[][0] [][1]  水平方向  [][2]竖直方向   arrive_group,arrive_group_copy 
				arrive_group[0][0] = trans_point[raw_slider_1].x; arrive_group[0][1] = trans_point[raw_slider_1].y; 
				arrive_group[0][2] = trans_point[raw_slider_1].z;
				arrive_group[1][0] = trans_point[raw_slider_2].x; arrive_group[1][1] = trans_point[raw_slider_2].y; 
				arrive_group[1][2] = trans_point[raw_slider_2].z;
				arrive_group[2][0] = trans_point[raw_slider_3].x; arrive_group[2][1] = trans_point[raw_slider_3].y;
				arrive_group[2][2] = trans_point[raw_slider_3].z;
				arrive_group[3][0] = trans_point[raw_slider_4].x; arrive_group[3][1] = trans_point[raw_slider_4].y;
				arrive_group[3][2] = trans_point[raw_slider_4].z;

				jude_direction_change();//重新确定方向

				have_arrive_1 = false; have_arrive_1_x = false; have_arrive_1_z = false; have_arrive_1_y = false;
				have_arrive_2 = false; have_arrive_2_x = false; have_arrive_2_z = false; have_arrive_2_y = false;
				have_arrive_3 = false; have_arrive_3_x = false; have_arrive_3_z = false; have_arrive_3_y = false;
				have_arrive_4 = false; have_arrive_4_x = false; have_arrive_4_z = false; have_arrive_4_y = false;
				have_one_loop = false;  //重新置位到达状态

			}
			else
			{
				have_arrive_1 = true;
				have_arrive_2 = true;
				have_arrive_3 = true;
				have_arrive_4 = true;
				have_one_loop = true;  //重新置位到达状态
			}


		}


		//定位器运送物体到指定点
		if (!have_one_loop)
		{
			do_movement_slider_1();
			do_movement_slider_2();
			do_movement_slider_3();
			do_movement_slider_4();

			if (have_arrive_1 && have_arrive_2 && have_arrive_3 && have_arrive_4)
			{
				have_one_loop = true;
			}
		}




		//---------------------------------------------
		//定位器底座
		model = glm::translate(model, model_pos); //定义模型每个循环出现的位置
		model = glm::scale(model, glm::vec3(scale_proportion, scale_proportion, scale_proportion));	// it's a bit too big for our scene, so scale it down
		ourShader.setMat4("model", model);
		ourModel.Draw(ourShader);

		//X_1
		// render the loaded model
		model_1 = glm::translate(model_1, model_pos_1); //定义模型每个循环出现的位置
		model_1 = glm::scale(model_1, glm::vec3(scale_proportion, scale_proportion, scale_proportion));	// it's a bit too big for our scene, so scale it down
		ourShader.setMat4("model", model_1);
		ourModel_1.Draw(ourShader);


		// Y_1
		// render the loaded model
		model_2 = glm::translate(model_2, model_pos_2); //定义模型每个循环出现的位置
		model_2 = glm::scale(model_2, glm::vec3(scale_proportion, scale_proportion, scale_proportion));	// it's a bit too big for our scene, so scale it down
		ourShader.setMat4("model", model_2);
		ourModel_2.Draw(ourShader);


		// Z_1
		// render the loaded model
		model_3 = glm::translate(model_3, model_pos_3); //定义模型每个循环出现的位置
		model_3 = glm::scale(model_3, glm::vec3(scale_proportion, scale_proportion, scale_proportion));	// it's a bit too big for our scene, so scale it down
		ourShader.setMat4("model", model_3);
		ourModel_3.Draw(ourShader);

		//_________________________________________________________________________________________________________________
		//定位器底座
		model_4 = glm::translate(model_4, model_pos_4); //定义模型每个循环出现的位置
		model_4 = glm::scale(model_4, glm::vec3(scale_proportion, scale_proportion, scale_proportion));	// it's a bit too big for our scene, so scale it down
		ourShader.setMat4("model", model_4);
		ourModel_4.Draw(ourShader);

		//X_1
		// render the loaded model
		model_5 = glm::translate(model_5, model_pos_5); //定义模型每个循环出现的位置
		model_5 = glm::scale(model_5, glm::vec3(scale_proportion, scale_proportion, scale_proportion));	// it's a bit too big for our scene, so scale it down
		ourShader.setMat4("model", model_5);
		ourModel_5.Draw(ourShader);


		// Y_1
		// render the loaded model
		model_6 = glm::translate(model_6, model_pos_6); //定义模型每个循环出现的位置
		model_6 = glm::scale(model_6, glm::vec3(scale_proportion, scale_proportion, scale_proportion));	// it's a bit too big for our scene, so scale it down
		ourShader.setMat4("model", model_6);
		ourModel_6.Draw(ourShader);


		// Z_1
		// render the loaded model
		model_7 = glm::translate(model_7, model_pos_7); //定义模型每个循环出现的位置
		model_7 = glm::scale(model_7, glm::vec3(scale_proportion, scale_proportion, scale_proportion));	// it's a bit too big for our scene, so scale it down
		ourShader.setMat4("model", model_7);
		ourModel_7.Draw(ourShader);

		//_______________________________________________________________________________________________________
		//定位器底座
		model_8 = glm::translate(model_8, model_pos_8); //定义模型每个循环出现的位置
		model_8 = glm::scale(model_8, glm::vec3(scale_proportion, scale_proportion, scale_proportion));	// it's a bit too big for our scene, so scale it down
		ourShader.setMat4("model", model_8);
		ourModel_8.Draw(ourShader);

		//X_1
		// render the loaded model
		model_9 = glm::translate(model_9, model_pos_9); //定义模型每个循环出现的位置
		model_9 = glm::scale(model_9, glm::vec3(scale_proportion, scale_proportion, scale_proportion));	// it's a bit too big for our scene, so scale it down
		ourShader.setMat4("model", model_9);
		ourModel_9.Draw(ourShader);


		// Y_1
		// render the loaded model
		model_10 = glm::translate(model_10, model_pos_10); //定义模型每个循环出现的位置
		model_10 = glm::scale(model_10, glm::vec3(scale_proportion, scale_proportion, scale_proportion));	// it's a bit too big for our scene, so scale it down
		ourShader.setMat4("model", model_10);
		ourModel_10.Draw(ourShader);


		// Z_1
		// render the loaded model
		model_11 = glm::translate(model_11, model_pos_11); //定义模型每个循环出现的位置
		model_11 = glm::scale(model_11, glm::vec3(scale_proportion, scale_proportion, scale_proportion));	// it's a bit too big for our scene, so scale it down
		ourShader.setMat4("model", model_11);
		ourModel_11.Draw(ourShader);

		//_____________________________________________________________________________________________________________________
		//定位器底座
		model_12 = glm::translate(model_12, model_pos_12); //定义模型每个循环出现的位置
		model_12 = glm::scale(model_12, glm::vec3(scale_proportion, scale_proportion, scale_proportion));	// it's a bit too big for our scene, so scale it down
		ourShader.setMat4("model", model_12);
		ourModel_12.Draw(ourShader);

		//X_1
		// render the loaded model
		model_13 = glm::translate(model_13, model_pos_13); //定义模型每个循环出现的位置
		model_13 = glm::scale(model_13, glm::vec3(scale_proportion, scale_proportion, scale_proportion));	// it's a bit too big for our scene, so scale it down
		ourShader.setMat4("model", model_13);
		ourModel_13.Draw(ourShader);


		// Y_1
		// render the loaded model
		model_14 = glm::translate(model_14, model_pos_14); //定义模型每个循环出现的位置
		model_14 = glm::scale(model_14, glm::vec3(scale_proportion, scale_proportion, scale_proportion));	// it's a bit too big for our scene, so scale it down
		ourShader.setMat4("model", model_14);
		ourModel_14.Draw(ourShader);


		// Z_1
		// render the loaded model
		model_15 = glm::translate(model_15, model_pos_15); //定义模型每个循环出现的位置
		model_15 = glm::scale(model_15, glm::vec3(scale_proportion, scale_proportion, scale_proportion));	// it's a bit too big for our scene, so scale it down
		ourShader.setMat4("model", model_15);
		ourModel_15.Draw(ourShader);

		//--------------------------------------------------------------------------------------------------------------------


		// 按键input
		// -----------------------------------------------------------------------
		processInput(window);

		// glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)
		// -------------------------------------------------------------------------------
		glfwSwapBuffers(window);
		glfwPollEvents();
	}

	// glfw: terminate, clearing all previously allocated GLFW resources.
	// ------------------------------------------------------------------
	glfwTerminate();
	return 0;
}

// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly
// ---------------------------------------------------------------------------------------------------------



void do_movement_slider_1()
{
	//-------------------------------------------------

	if (!have_arrive_1_x && !have_arrive_1_z && !have_arrive_1_y) //走x方向
	{
		model_pos_1.x += smooth_steps*slider_1_x_dir_value_change;
		model_pos_2.x += smooth_steps*slider_1_x_dir_value_change;
		model_pos_3.x += smooth_steps*slider_1_x_dir_value_change;
		steps_slider_1++;

		if (steps_slider_1 >= 1 / smooth_steps)
		{
			have_arrive_1_x = true;
			steps_slider_1 = 0;
		}
	}


	if (have_arrive_1_x && !have_arrive_1_z && !have_arrive_1_y)  //走完Z向
	{
		model_pos_2.z += smooth_steps*slider_1_z_dir_value_change;
		model_pos_3.z += smooth_steps*slider_1_z_dir_value_change;
		steps_slider_1++;

		if (steps_slider_1 >= 1 / smooth_steps)
		{
			have_arrive_1_z = true;
			steps_slider_1 = 0;

		}

	}


	if (have_arrive_1_x && have_arrive_1_z && !have_arrive_1_y)  //走完y向
	{
		model_pos_3.y += smooth_steps*slider_1_y_dir_value_change;
		steps_slider_1++;

		if (steps_slider_1 >= 1 / smooth_steps)
		{
			have_arrive_1_y = true;
			steps_slider_1 = 0;
		}
	}

	if (have_arrive_1_x && have_arrive_1_z && have_arrive_1_y)
	{
		have_arrive_1 = true;
		steps_slider_1 = 0;
	}

}



void do_movement_slider_2()
{


	//---------------------------------------------
	if (!have_arrive_2_x && !have_arrive_2_z && !have_arrive_2_y) //走完x方向
	{

		model_pos_5.x += smooth_steps*slider_2_x_dir_value_change;
		model_pos_6.x += smooth_steps*slider_2_x_dir_value_change;
		model_pos_7.x += smooth_steps*slider_2_x_dir_value_change;
		steps_slider_2++;

		if (steps_slider_2 >= 1 / smooth_steps)
		{
			have_arrive_2_x = true;
			steps_slider_2 = 0;

		}

	}

	if (have_arrive_2_x && !have_arrive_2_z && !have_arrive_2_y)
	{
		model_pos_6.z += smooth_steps*slider_2_z_dir_value_change;
		model_pos_7.z += smooth_steps*slider_2_z_dir_value_change;
		steps_slider_2++;

		if (steps_slider_2 >= 1 / smooth_steps)
		{
			have_arrive_2_z = true;
			steps_slider_2 = 0;
		}
	}

	if (have_arrive_2_x && have_arrive_2_z && !have_arrive_2_y)
	{
		model_pos_7.y += smooth_steps*slider_2_y_dir_value_change;
		steps_slider_2++;

		if (steps_slider_2 >= 1 / smooth_steps)
		{
			have_arrive_2_y = true;
			steps_slider_2 = 0;
		}
	}


	if (have_arrive_2_x && have_arrive_2_z && have_arrive_2_y)
	{
		have_arrive_2 = true;
	}



}

void do_movement_slider_3()
{

	//------------------------------------------------
	if (!have_arrive_3_x && !have_arrive_3_z && !have_arrive_3_y) //走完x方向
	{

		model_pos_9.x += smooth_steps*slider_3_x_dir_value_change;
		model_pos_10.x += smooth_steps*slider_3_x_dir_value_change;
		model_pos_11.x += smooth_steps*slider_3_x_dir_value_change;
		steps_slider_3++;

		if (steps_slider_3 >= 1 / smooth_steps)
		{
			have_arrive_3_x = true;
			steps_slider_3 = 0;
		}

	}

	if (have_arrive_3_x && !have_arrive_3_z && !have_arrive_3_y)
	{
		model_pos_10.z += smooth_steps*slider_3_z_dir_value_change;
		model_pos_11.z += smooth_steps*slider_3_z_dir_value_change;
		steps_slider_3++;

		if (steps_slider_3 >= 1 / smooth_steps)
		{
			have_arrive_3_z = true;
			steps_slider_3 = 0;

		}
	}


	if (have_arrive_3_x && have_arrive_3_z && !have_arrive_3_y)
	{
		model_pos_11.y += smooth_steps*slider_3_y_dir_value_change;
		steps_slider_3++;

		if (steps_slider_3 >= 1 / smooth_steps)
		{
			have_arrive_3_y = true;
			steps_slider_3 = 0;
		}
	}

	if (have_arrive_3_x && have_arrive_3_z && have_arrive_3_y)
	{
		have_arrive_3 = true;
	}


}


void do_movement_slider_4()
{
	//---------------------------------
	if (!have_arrive_4_x && !have_arrive_4_z && !have_arrive_4_y) //走完x方向
	{
		model_pos_13.x += smooth_steps*slider_4_x_dir_value_change;
		model_pos_14.x += smooth_steps*slider_4_x_dir_value_change;
		model_pos_15.x += smooth_steps*slider_4_x_dir_value_change;
		steps_slider_4++;

		if (steps_slider_4 >= 1 / smooth_steps)
		{
			have_arrive_4_x = true;
			steps_slider_4 = 0;
		}
	}


	if (have_arrive_4_x && !have_arrive_4_z && !have_arrive_4_y)
	{
		model_pos_14.z += smooth_steps*slider_4_z_dir_value_change;
		model_pos_15.z += smooth_steps*slider_4_z_dir_value_change;
		steps_slider_4++;

		if (steps_slider_4 >= 1 / smooth_steps)
		{
			have_arrive_4_z = true;
			steps_slider_4 = 0;
		}
	}


	if (have_arrive_4_x && have_arrive_4_z && !have_arrive_4_y)
	{
		model_pos_15.y += smooth_steps*slider_4_y_dir_value_change;
		steps_slider_4++;

		if (steps_slider_4 >= 1 / smooth_steps)
		{
			have_arrive_4_y = true;
			steps_slider_4 = 0;
		}
	}


	if (have_arrive_4_x && have_arrive_4_z && have_arrive_4_y)
	{
		have_arrive_4 = true;
	}

}


void  jude_direction_change()
{
	//注意现实坐标系和 仿真空间坐标系之间的 映射
	slider_1_x_dir_value_change = magnify_slidermove*(arrive_group[0][0]-arrive_group_copy[0][0]);
	slider_1_z_dir_value_change = magnify_slidermove*(arrive_group[0][1] - arrive_group_copy[0][1]);
	slider_1_y_dir_value_change = magnify_slidermove*(arrive_group[0][2] - arrive_group_copy[0][2]);

	slider_2_x_dir_value_change = magnify_slidermove*(arrive_group[1][0] - arrive_group_copy[1][0]);
	slider_2_z_dir_value_change = magnify_slidermove*(arrive_group[1][1] - arrive_group_copy[1][1]);
	slider_2_y_dir_value_change = magnify_slidermove*(arrive_group[1][2] - arrive_group_copy[1][2]);

	slider_3_x_dir_value_change = magnify_slidermove*(arrive_group[2][0] - arrive_group_copy[2][0]);
	slider_3_z_dir_value_change = magnify_slidermove*(arrive_group[2][1] - arrive_group_copy[2][1]);
	slider_3_y_dir_value_change = magnify_slidermove*(arrive_group[2][2] - arrive_group_copy[2][2]);

	slider_4_x_dir_value_change = magnify_slidermove*(arrive_group[3][0] - arrive_group_copy[3][0]);
	slider_4_z_dir_value_change = magnify_slidermove*(arrive_group[3][1] - arrive_group_copy[3][1]);
	slider_4_y_dir_value_change = magnify_slidermove*(arrive_group[3][2] - arrive_group_copy[3][2]);

}

















//void jude_direction()
//{
//
//	//--------------------------------------------------------------
//	//1号定位器各轴移动方向
//	//通过对glm::vec3(arrive_1.x - arrive_1_copy.x, 0, 0) 的检测，勉强能够达到七位有效数字的精度
//
//	slider_1_x_direction = magnify_slidermove *glm::vec3(arrive_1.x - arrive_1_copy.x, 0, 0);
//	slider_1_z_direction = magnify_slidermove *glm::vec3(0, 0, arrive_1.z - arrive_1_copy.z);
//	slider_1_y_direction = magnify_slidermove *glm::vec3(0, arrive_1.y - arrive_1_copy.y, 0);
//
//	//--------------------------------------------------------------
//	//2号定位器各轴移动方向
//
//	slider_2_x_direction = magnify_slidermove *glm::vec3(arrive_2.x - arrive_2_copy.x, 0, 0);
//	slider_2_z_direction = magnify_slidermove *glm::vec3(0, 0, arrive_2.z - arrive_2_copy.z);
//	slider_2_y_direction = magnify_slidermove *glm::vec3(0, arrive_2.y - arrive_2_copy.y, 0);
//
//
//	//--------------------------------------------------------------
//	//3号定位器各轴移动方向
//
//	slider_3_x_direction = magnify_slidermove *glm::vec3(arrive_3.x - arrive_3_copy.x, 0, 0);
//	slider_3_z_direction = magnify_slidermove *glm::vec3(0, 0, arrive_3.z - arrive_3_copy.z);
//	slider_3_y_direction = magnify_slidermove *glm::vec3(0, arrive_3.y - arrive_3_copy.y, 0);
//
//	//--------------------------------------------------------------
//	//4号定位器各轴移动方向
//
//	slider_4_x_direction = magnify_slidermove *glm::vec3(arrive_4.x - arrive_4_copy.x, 0, 0);
//	slider_4_z_direction = magnify_slidermove *glm::vec3(0, 0, arrive_4.z - arrive_4_copy.z);
//	slider_4_y_direction = magnify_slidermove *glm::vec3(0, arrive_4.y - arrive_4_copy.y, 0);
//
//}



/*
void jude_direction()
{

//--------------------------------------------------------------
//1号定位器各轴移动方向
if (arrive_1.x - model_pos_3.x > 0)
{
slider_1_x_direction = 1.0f*x_direction;
}
else
{
slider_1_x_direction = -1.0f*x_direction;
}

if (arrive_1.z - model_pos_3.z > 0)
{
slider_1_z_direction = 1.0f*z_direction;
}
else
{
slider_1_z_direction = -1.0f*z_direction;
}



if (arrive_1.y - model_pos_3.y > 0)
{
slider_1_y_direction = 1.0f*y_direction;
}
else
{
slider_1_y_direction = -1.0f*y_direction;
}



//--------------------------------------------------------------
//2号定位器各轴移动方向
if (arrive_2.x - model_pos_7.x > 0)
{
slider_2_x_direction = 1.0f*x_direction;
}
else {
slider_2_x_direction = -1.0f*x_direction;
}



if (arrive_2.z - model_pos_7.z > 0) {
slider_2_z_direction = 1.0f*z_direction;
}

else {
slider_2_z_direction = -1.0f*z_direction;
}



if (arrive_2.y - model_pos_7.y > 0) {
slider_2_y_direction = 1.0f*y_direction;
}

else {
slider_2_y_direction = -1.0f*y_direction;
}



//--------------------------------------------------------------
//3号定位器各轴移动方向
if (arrive_3.x - model_pos_11.x > 0) {
slider_3_x_direction = 1.0f*x_direction;
}

else {
slider_3_x_direction = -1.0f*x_direction;
}

if (arrive_3.z - model_pos_11.z > 0) {
slider_3_z_direction = 1.0f*z_direction;
}
else {
slider_3_z_direction = -1.0f*z_direction;
}

if (arrive_3.y - model_pos_11.y > 0) {
slider_3_y_direction = 1.0f*y_direction;
}
else {
slider_3_y_direction = -1.0f*y_direction;
}


//--------------------------------------------------------------
//四号定位器各轴移动方向
if (arrive_4.x - model_pos_15.x > 0) {
slider_4_x_direction = 1.0f*x_direction;
}
else {
slider_4_x_direction = -1.0f*x_direction;
}

if (arrive_4.z - model_pos_15.z > 0) {
slider_4_z_direction = 1.0f*z_direction;
}
else {
slider_4_z_direction = -1.0f*z_direction;
}
if (arrive_4.y - model_pos_15.y > 0) {
slider_4_y_direction = 1.0f*y_direction;
}
else {
slider_4_y_direction = -1.0f*y_direction;
}


}*/


void processInput(GLFWwindow* window)
{
	//float  angle = 0.0f;

	glm::vec3 front = glm::vec3(0.0f, 0.0f, -1.0f);
	float cameraSpeed = 2.5f * deltaTime;
	//float cameraSpeed = 0.05f; // adjust accordingly
	if (glfwGetKey(window, GLFW_KEY_UP) == GLFW_PRESS)
		cameraPos += cameraSpeed * cameraFront;
	if (glfwGetKey(window, GLFW_KEY_DOWN) == GLFW_PRESS)
		cameraPos -= cameraSpeed * cameraFront;
	if (glfwGetKey(window, GLFW_KEY_RIGHT) == GLFW_PRESS)
		cameraPos -= glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;
	if (glfwGetKey(window, GLFW_KEY_LEFT) == GLFW_PRESS)
		cameraPos += glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;

	if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
		glfwSetWindowShouldClose(window, true);
}






// glfw: whenever the window size changed (by OS or user resize) this callback function executes
// ---------------------------------------------------------------------------------------------
void framebuffer_size_callback(GLFWwindow* window, int width, int height)
{
	// make sure the viewport matches the new window dimensions; note that width and 
	// height will be significantly larger than specified on retina displays.
	glViewport(0, 0, width, height);
}



// glfw: whenever the mouse scroll wheel scrolls, this callback is called
// ----------------------------------------------------------------------
void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)
{
	if (fov >= 1.0f && fov <= 45.0f)
		fov -= yoffset;
	if (fov <= 1.0f)
		fov = 1.0f;
	if (fov >= 45.0f)
		fov = 45.0f;
}

void key_callback(GLFWwindow* window, int key, int scancode, int action, int mode)
{
	if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)
		glfwSetWindowShouldClose(window, GL_TRUE);
	if (key >= 0 && key < 1024)
	{
		//设置按下/释放键为true或false
		if (action == GLFW_PRESS)
			keys[key] = true;
		else if (action == GLFW_RELEASE)
			keys[key] = false;
	}

}

// glfw: whenever the mouse moves, this callback is called
// -------------------------------------------------------
void mouse_callback(GLFWwindow* window, double xpos, double ypos)
{


	if (firstMouse)
	{
		lastX = xpos;
		lastY = ypos;
		firstMouse = false;
	}

	float xoffset = xpos - lastX;
	float yoffset = lastY - ypos;
	lastX = xpos;
	lastY = ypos;

	float sensitivity = 0.1;
	xoffset *= sensitivity;
	yoffset *= sensitivity;

	yaw += xoffset;
	pitch += yoffset;

	if (pitch > 89.0f)
		pitch = 89.0f;
	if (pitch < -89.0f)
		pitch = -89.0f;

	glm::vec3 front;
	front.x = cos(glm::radians(yaw)) * cos(glm::radians(pitch));
	front.y = sin(glm::radians(pitch));
	front.z = sin(glm::radians(yaw)) * cos(glm::radians(pitch));

	//--------------------------------------------
	//视角锁定 Version1.0
	if (viewlocker == 1.0)
	{
		cameraFront = glm::normalize(front);
		cameraFront_now = cameraFront;
	}
	if (viewlocker == 0.0)
	{
		cameraFront = cameraFront_now;//摄像机视线方向
									  //cameraUp = glm::vec3(0.0f, 1.0f, 0.0f);
	}

}

void jude_viewlock()
{
	if (keys[GLFW_KEY_X])//X 视角解锁
	{
		viewlocker = 1.0;
	}
	if (keys[GLFW_KEY_C])//C  视角锁定
	{
		viewlocker = 0.0;
	}
}


void judge_move()
{

	//前进后退计算更新位置向量
	if (keys[GLFW_KEY_A])
	{
		model_pos_1 += velocity*x_direction;
		model_pos_2 += velocity*x_direction;
		model_pos_3 += velocity*x_direction;

		model_pos_5 += velocity*x_direction;
		model_pos_6 += velocity*x_direction;
		model_pos_7 += velocity*x_direction;

		model_pos_9 += velocity*x_direction;
		model_pos_10 += velocity*x_direction;
		model_pos_11 += velocity*x_direction;

		model_pos_13 += velocity*x_direction;
		model_pos_14 += velocity*x_direction;
		model_pos_15 += velocity*x_direction;
	}
	if (keys[GLFW_KEY_D])
	{
		model_pos_1 -= velocity*x_direction;
		model_pos_2 -= velocity*x_direction;
		model_pos_3 -= velocity*x_direction;

		model_pos_5 -= velocity*x_direction;
		model_pos_6 -= velocity*x_direction;
		model_pos_7 -= velocity*x_direction;

		model_pos_9 -= velocity*x_direction;
		model_pos_10 -= velocity*x_direction;
		model_pos_11 -= velocity*x_direction;

		model_pos_13 -= velocity*x_direction;
		model_pos_14 -= velocity*x_direction;
		model_pos_15 -= velocity*x_direction;
	}

	if (keys[GLFW_KEY_W])
	{
		model_pos_2 += velocity*z_direction;
		model_pos_3 += velocity*z_direction;

		model_pos_6 += velocity*z_direction;
		model_pos_7 += velocity*z_direction;

		model_pos_10 += velocity*z_direction;
		model_pos_11 += velocity*z_direction;

		model_pos_14 += velocity*z_direction;
		model_pos_15 += velocity*z_direction;
	}
	if (keys[GLFW_KEY_S])
	{
		model_pos_2 -= velocity*z_direction;
		model_pos_3 -= velocity*z_direction;

		model_pos_6 -= velocity*z_direction;
		model_pos_7 -= velocity*z_direction;

		model_pos_10 -= velocity*z_direction;
		model_pos_11 -= velocity*z_direction;

		model_pos_14 -= velocity*z_direction;
		model_pos_15 -= velocity*z_direction;
	}

	if (keys[GLFW_KEY_R])
	{
		model_pos_3 += velocity*y_direction;
		model_pos_7 += velocity*y_direction;
		model_pos_11 += velocity*y_direction;
		model_pos_15 += velocity*y_direction;
	}
	if (keys[GLFW_KEY_F])
	{
		model_pos_3 -= velocity*y_direction;
		model_pos_7 -= velocity*y_direction;
		model_pos_11 -= velocity*y_direction;
		model_pos_15 -= velocity*y_direction;
	}

}
